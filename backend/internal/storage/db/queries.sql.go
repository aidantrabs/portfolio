// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createExperience = `-- name: CreateExperience :one
INSERT INTO experience (
    company,
    position,
    location,
    start_date,
    end_date,
    current,
    description,
    technologies,
    company_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, company, position, location, start_date, end_date, current, description, technologies, company_url, created_at, updated_at
`

type CreateExperienceParams struct {
	Company      string         `json:"company"`
	Position     string         `json:"position"`
	Location     sql.NullString `json:"location"`
	StartDate    time.Time      `json:"start_date"`
	EndDate      sql.NullTime   `json:"end_date"`
	Current      sql.NullBool   `json:"current"`
	Description  []string       `json:"description"`
	Technologies []string       `json:"technologies"`
	CompanyUrl   sql.NullString `json:"company_url"`
}

func (q *Queries) CreateExperience(ctx context.Context, arg CreateExperienceParams) (Experience, error) {
	row := q.queryRow(ctx, q.createExperienceStmt, createExperience,
		arg.Company,
		arg.Position,
		arg.Location,
		arg.StartDate,
		arg.EndDate,
		arg.Current,
		pq.Array(arg.Description),
		pq.Array(arg.Technologies),
		arg.CompanyUrl,
	)
	var i Experience
	err := row.Scan(
		&i.ID,
		&i.Company,
		&i.Position,
		&i.Location,
		&i.StartDate,
		&i.EndDate,
		&i.Current,
		pq.Array(&i.Description),
		pq.Array(&i.Technologies),
		&i.CompanyUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    title,
    slug,
    description,
    technologies,
    image_url,
    project_url,
    github_url,
    featured
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, title, slug, description, technologies, image_url, project_url, github_url, featured, created_at, updated_at
`

type CreateProjectParams struct {
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Description  sql.NullString `json:"description"`
	Technologies []string       `json:"technologies"`
	ImageUrl     sql.NullString `json:"image_url"`
	ProjectUrl   sql.NullString `json:"project_url"`
	GithubUrl    sql.NullString `json:"github_url"`
	Featured     sql.NullBool   `json:"featured"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.queryRow(ctx, q.createProjectStmt, createProject,
		arg.Title,
		arg.Slug,
		arg.Description,
		pq.Array(arg.Technologies),
		arg.ImageUrl,
		arg.ProjectUrl,
		arg.GithubUrl,
		arg.Featured,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		pq.Array(&i.Technologies),
		&i.ImageUrl,
		&i.ProjectUrl,
		&i.GithubUrl,
		&i.Featured,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username,
    password_hash,
    email
) VALUES (
    $1, $2, $3
)
RETURNING id, username, password_hash, email, created_at, updated_at
`

type CreateUserParams struct {
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
	Email        string `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser, arg.Username, arg.PasswordHash, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExperience = `-- name: DeleteExperience :exec
DELETE FROM experience WHERE id = $1
`

func (q *Queries) DeleteExperience(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteExperienceStmt, deleteExperience, id)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteProjectStmt, deleteProject, id)
	return err
}

const getAbout = `-- name: GetAbout :one
SELECT id, bio, skills, resume_url, social_links, created_at, updated_at FROM about
WHERE id = 1 LIMIT 1
`

func (q *Queries) GetAbout(ctx context.Context) (About, error) {
	row := q.queryRow(ctx, q.getAboutStmt, getAbout)
	var i About
	err := row.Scan(
		&i.ID,
		&i.Bio,
		pq.Array(&i.Skills),
		&i.ResumeUrl,
		&i.SocialLinks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCurrentExperience = `-- name: GetCurrentExperience :many
SELECT id, company, position, location, start_date, end_date, current, description, technologies, company_url, created_at, updated_at FROM experience
WHERE current = true
ORDER BY start_date DESC
`

func (q *Queries) GetCurrentExperience(ctx context.Context) ([]Experience, error) {
	rows, err := q.query(ctx, q.getCurrentExperienceStmt, getCurrentExperience)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Experience{}
	for rows.Next() {
		var i Experience
		if err := rows.Scan(
			&i.ID,
			&i.Company,
			&i.Position,
			&i.Location,
			&i.StartDate,
			&i.EndDate,
			&i.Current,
			pq.Array(&i.Description),
			pq.Array(&i.Technologies),
			&i.CompanyUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeaturedProjects = `-- name: GetFeaturedProjects :many
SELECT id, title, slug, description, technologies, image_url, project_url, github_url, featured, created_at, updated_at FROM projects
WHERE featured = true
ORDER BY created_at DESC
`

func (q *Queries) GetFeaturedProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.query(ctx, q.getFeaturedProjectsStmt, getFeaturedProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			pq.Array(&i.Technologies),
			&i.ImageUrl,
			&i.ProjectUrl,
			&i.GithubUrl,
			&i.Featured,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPastExperience = `-- name: GetPastExperience :many
SELECT id, company, position, location, start_date, end_date, current, description, technologies, company_url, created_at, updated_at FROM experience
WHERE current = false
ORDER BY start_date DESC
`

func (q *Queries) GetPastExperience(ctx context.Context) ([]Experience, error) {
	rows, err := q.query(ctx, q.getPastExperienceStmt, getPastExperience)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Experience{}
	for rows.Next() {
		var i Experience
		if err := rows.Scan(
			&i.ID,
			&i.Company,
			&i.Position,
			&i.Location,
			&i.StartDate,
			&i.EndDate,
			&i.Current,
			pq.Array(&i.Description),
			pq.Array(&i.Technologies),
			&i.CompanyUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectBySlug = `-- name: GetProjectBySlug :one
SELECT id, title, slug, description, technologies, image_url, project_url, github_url, featured, created_at, updated_at FROM projects
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetProjectBySlug(ctx context.Context, slug string) (Project, error) {
	row := q.queryRow(ctx, q.getProjectBySlugStmt, getProjectBySlug, slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		pq.Array(&i.Technologies),
		&i.ImageUrl,
		&i.ProjectUrl,
		&i.GithubUrl,
		&i.Featured,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, email, created_at, updated_at FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserByUsernameStmt, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listExperience = `-- name: ListExperience :many
SELECT id, company, position, location, start_date, end_date, current, description, technologies, company_url, created_at, updated_at FROM experience
ORDER BY start_date DESC
`

func (q *Queries) ListExperience(ctx context.Context) ([]Experience, error) {
	rows, err := q.query(ctx, q.listExperienceStmt, listExperience)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Experience{}
	for rows.Next() {
		var i Experience
		if err := rows.Scan(
			&i.ID,
			&i.Company,
			&i.Position,
			&i.Location,
			&i.StartDate,
			&i.EndDate,
			&i.Current,
			pq.Array(&i.Description),
			pq.Array(&i.Technologies),
			&i.CompanyUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, title, slug, description, technologies, image_url, project_url, github_url, featured, created_at, updated_at FROM projects
ORDER BY created_at DESC
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.query(ctx, q.listProjectsStmt, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			pq.Array(&i.Technologies),
			&i.ImageUrl,
			&i.ProjectUrl,
			&i.GithubUrl,
			&i.Featured,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjects = `-- name: SearchProjects :many
SELECT id, title, slug, description, technologies, image_url, project_url, github_url, featured, created_at, updated_at FROM projects
WHERE 
    title ILIKE '%' || $1 || '%'
    OR description ILIKE '%' || $1 || '%'
    OR array_to_string(technologies, ',') ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
`

func (q *Queries) SearchProjects(ctx context.Context, dollar_1 sql.NullString) ([]Project, error) {
	rows, err := q.query(ctx, q.searchProjectsStmt, searchProjects, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			pq.Array(&i.Technologies),
			&i.ImageUrl,
			&i.ProjectUrl,
			&i.GithubUrl,
			&i.Featured,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExperience = `-- name: UpdateExperience :one
UPDATE experience
SET
    company = $2,
    position = $3,
    location = $4,
    start_date = $5,
    end_date = $6,
    current = $7,
    description = $8,
    technologies = $9,
    company_url = $10,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, company, position, location, start_date, end_date, current, description, technologies, company_url, created_at, updated_at
`

type UpdateExperienceParams struct {
	ID           int32          `json:"id"`
	Company      string         `json:"company"`
	Position     string         `json:"position"`
	Location     sql.NullString `json:"location"`
	StartDate    time.Time      `json:"start_date"`
	EndDate      sql.NullTime   `json:"end_date"`
	Current      sql.NullBool   `json:"current"`
	Description  []string       `json:"description"`
	Technologies []string       `json:"technologies"`
	CompanyUrl   sql.NullString `json:"company_url"`
}

func (q *Queries) UpdateExperience(ctx context.Context, arg UpdateExperienceParams) (Experience, error) {
	row := q.queryRow(ctx, q.updateExperienceStmt, updateExperience,
		arg.ID,
		arg.Company,
		arg.Position,
		arg.Location,
		arg.StartDate,
		arg.EndDate,
		arg.Current,
		pq.Array(arg.Description),
		pq.Array(arg.Technologies),
		arg.CompanyUrl,
	)
	var i Experience
	err := row.Scan(
		&i.ID,
		&i.Company,
		&i.Position,
		&i.Location,
		&i.StartDate,
		&i.EndDate,
		&i.Current,
		pq.Array(&i.Description),
		pq.Array(&i.Technologies),
		&i.CompanyUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET 
    title = $2,
    description = $3,
    technologies = $4,
    image_url = $5,
    project_url = $6,
    github_url = $7,
    featured = $8,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, title, slug, description, technologies, image_url, project_url, github_url, featured, created_at, updated_at
`

type UpdateProjectParams struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Description  sql.NullString `json:"description"`
	Technologies []string       `json:"technologies"`
	ImageUrl     sql.NullString `json:"image_url"`
	ProjectUrl   sql.NullString `json:"project_url"`
	GithubUrl    sql.NullString `json:"github_url"`
	Featured     sql.NullBool   `json:"featured"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.queryRow(ctx, q.updateProjectStmt, updateProject,
		arg.ID,
		arg.Title,
		arg.Description,
		pq.Array(arg.Technologies),
		arg.ImageUrl,
		arg.ProjectUrl,
		arg.GithubUrl,
		arg.Featured,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		pq.Array(&i.Technologies),
		&i.ImageUrl,
		&i.ProjectUrl,
		&i.GithubUrl,
		&i.Featured,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAbout = `-- name: UpsertAbout :one
INSERT INTO about (
    id,
    bio,
    skills,
    resume_url,
    social_links
) VALUES (
    1, $1, $2, $3, $4
)
ON CONFLICT (id) DO UPDATE
SET 
    bio = EXCLUDED.bio,
    skills = EXCLUDED.skills,
    resume_url = EXCLUDED.resume_url,
    social_links = EXCLUDED.social_links,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, bio, skills, resume_url, social_links, created_at, updated_at
`

type UpsertAboutParams struct {
	Bio         string                `json:"bio"`
	Skills      []string              `json:"skills"`
	ResumeUrl   sql.NullString        `json:"resume_url"`
	SocialLinks pqtype.NullRawMessage `json:"social_links"`
}

func (q *Queries) UpsertAbout(ctx context.Context, arg UpsertAboutParams) (About, error) {
	row := q.queryRow(ctx, q.upsertAboutStmt, upsertAbout,
		arg.Bio,
		pq.Array(arg.Skills),
		arg.ResumeUrl,
		arg.SocialLinks,
	)
	var i About
	err := row.Scan(
		&i.ID,
		&i.Bio,
		pq.Array(&i.Skills),
		&i.ResumeUrl,
		&i.SocialLinks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
